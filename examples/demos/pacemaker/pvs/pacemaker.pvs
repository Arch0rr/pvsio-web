pacemaker: THEORY
 BEGIN
  IMPORTING LRI, AVI, PVARP, URI, VRP

  State: TYPE = [#
     avi: AVI.state,
     lri: LRI.state,
     pvarp: PVARP.state,
     uri: URI.state,
     vrp: VRP.state
  #]

  init_pacemaker: State = (#
     avi := init_AVI,
     lri := init_LRI,
     pvarp := init_PVARP,
     uri := init_URI,
     vrp := init_VRP
  #)


  %-- events generated by LRI
  per_APevent(st: State): bool = per_APout(lri(st))
  APevent(st: (per_APevent)): State =
   %LET dbg = println("LRI.AP!") IN
     st WITH [ lri := IF per_APout(lri(st)) THEN APout(lri(st)) ELSE lri(st) ENDIF,
     	       avi := IF per_APin(avi(st)) THEN APin(avi(st)) ELSE avi(st) ENDIF ]

  per_LRItick(st: State): bool = per_tick(lri(st))
  LRItick(st: (per_LRItick)): State = 
   %LET dbg = println("LRI.tick") IN
    st WITH [ lri := tick(lri(st)) ]


  %-- events generated by AVI -- we need to handle the global clock here and in VSevent
  per_VPevent(st: State): bool = per_VPout(avi(st))
  VPevent(st: (per_VPevent)): State =
   LET %dbg = println("AVI.VP!"),
       updateCLK = per_VPin(uri(st)),
       st = st WITH [ avi := IF per_VPout(avi(st)) THEN VPout(avi(st)) ELSE avi(st) ENDIF,
     	              lri := IF per_VPin(lri(st)) THEN VPin(lri(st)) ELSE lri(st) ENDIF,
     	       	      pvarp := IF per_VPin(pvarp(st)) THEN VPin(pvarp(st)) ELSE pvarp(st) ENDIF,
	       	      uri := IF per_VPin(uri(st)) THEN VPin(uri(st)) ELSE uri(st) ENDIF,
	       	      vrp := IF per_VPin(vrp(st)) THEN VPin(vrp(st)) ELSE vrp(st) ENDIF ]
    IN IF updateCLK THEN st WITH [ avi := avi(st) WITH [ clk := clk(uri(st)) ]] ELSE st ENDIF
    

  per_AVItick(st: State): bool = per_tick(avi(st))
  AVItick(st: (per_AVItick)): State = 
   %LET dbg = IF NOT per_delay(avi(st)) THEN println("AVI.tick") ELSE true ENDIF IN
    st WITH [ avi := tick(avi(st)) ]


  %-- events generated by PVARP
  per_ASevent(st: State): bool = per_ASout(pvarp(st))
  ASevent(st: (per_ASevent)): State =
   %LET dbg = println("PVARP.AS!") IN
     st WITH [ pvarp := IF per_ASout(pvarp(st)) THEN ASout(pvarp(st)) ELSE pvarp(st) ENDIF,
     	       avi := IF per_ASin(avi(st)) THEN ASin(avi(st)) ELSE avi(st) ENDIF,
     	       lri := IF per_ASin(lri(st)) THEN ASin(lri(st)) ELSE lri(st) ENDIF ]

  per_PVARPtick(st: State): bool = per_tick(pvarp(st))
  PVARPtick(st: (per_PVARPtick)): State = 
   %LET dbg = println("PVARP.tick") IN
    st WITH [ pvarp := tick(pvarp(st)) ]


  %-- events generated by VRP -- we need to handle the global clock here as in VPevent
  per_VSevent(st: State): bool = per_VSout(vrp(st))
  VSevent(st: (per_VSevent)): State =
   LET %dbg = println("VRP.VS!"),
       updateCLK = per_VSin(uri(st)),
       st = st WITH [ vrp := IF per_VSout(vrp(st)) THEN VSout(vrp(st)) ELSE vrp(st) ENDIF,
     	              lri := IF per_VSin(lri(st)) THEN VSin(lri(st)) ELSE lri(st) ENDIF,
     	              pvarp := IF per_VSin(pvarp(st)) THEN VSin(pvarp(st)) ELSE pvarp(st) ENDIF,
	              uri := IF per_VSin(uri(st)) THEN VSin(uri(st)) ELSE uri(st) ENDIF,
	              avi := IF per_VSin(avi(st)) THEN VSin(avi(st)) ELSE avi(st) ENDIF ]
    IN IF updateCLK THEN st WITH [ avi := avi(st) WITH [ clk := clk(uri(st)) ]] ELSE st ENDIF


  per_VRPtick(st: State): bool = per_tick(vrp(st))
  VRPtick(st: (per_VRPtick)): State = 
   %LET dbg = println("VRP.tick") IN
    st WITH [ vrp := tick(vrp(st)) ]


  %-- utility functions for handling execution of components
  exec_LRI(st: State): State =
    LET st =
     IF per_APevent(st) THEN APevent(st)
     ELSIF per_LRItick(st) THEN LRItick(st)
     ELSE st ENDIF
    IN st WITH [ lri := advance_time(lri(st)) ]

  exec_AVI(st: State): State =
    LET st =
     IF per_VPevent(st) THEN VPevent(st)
     ELSIF per_AVItick(st) THEN AVItick(st)
     ELSE st ENDIF
    IN st WITH [ avi := advance_time(avi(st)) ]

  exec_PVARP(st: State): State =
    LET st =
     IF per_ASevent(st) THEN ASevent(st)
     ELSIF per_PVARPtick(st) THEN PVARPtick(st)
     ELSE st ENDIF
    IN st WITH [ pvarp := advance_time(pvarp(st)) ]

  exec_VRP(st: State): State =
    LET st =
     IF per_VSevent(st) THEN VSevent(st) 
     ELSIF per_VRPtick(st) THEN VRPtick(st)
     ELSE st ENDIF
    IN st WITH [ vrp := advance_time(vrp(st)) ]

  exec_URI(st: State): State = st WITH [ uri := tick(uri(st)) ]

  %-- parallel execution of the state machines (1 step)
  exec_aux(st: State): State =
    LET st = exec_LRI(st),
    	st = exec_AVI(st),
        st = exec_PVARP(st),
        st = exec_VRP(st),
	st = exec_URI(st)
     IN st

  %-- parallel execution of the state machines (n steps)
  exec(fuel: nat)(st: State): RECURSIVE State =
    IF fuel = 0 THEN st
    ELSE LET st_prime = exec_aux(st) IN exec(fuel - 1)(st_prime) ENDIF
   MEASURE fuel
    

  %-- execution example
  test1: State = exec(12000)(init_pacemaker);
  

 END pacemaker
