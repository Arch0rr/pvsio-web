gpcaui: THEORY
 BEGIN
 
  %-- constants
  max: posreal = 99999;
  alarmType: TYPE = {silent, beep, muted}

  %-- type definitions
  %-- data entry
  device_real: TYPE = {r: nonneg_real | r <= max}
  Cursor: TYPE = {i: int | i >= -2 AND i <= 4}
  Memory: DATATYPE
   BEGIN
     mem(value: device_real): valid?
     NA: NA?   
   END Memory

  % 42->93->4F->86->88->51->8A->8C->8E->48->4D->4A->4E->94
  ControllerCMD: TYPE = { CINIT, 
			  %-- POST Routine
  		      	  C42, %-- power up
			  C93, %-- check administration set
			  %-- Check Drug Routine
			  C4F, 
			  C86, 
			  C88, 
			  C51, 
			  C8A, 
			  C8C, 
			  C8E, 
			  %-- Infusion Configuration Routine
  		      	  C48, %-- configure infusion program
 			  C4D, %-- confirm VTBI
			  C4A, %-- confirm rate
			  C4E, %-- confirm infusion program
			  C94, %-- start infusion
			  C43, %-- pause infusion
			  C44, %-- confirm pause
			  C46, %-- resume infusion
			  C41, %-- stop infusion
			  CREADY }

  device_unit: TYPE = { mL_hour, mL }
  rate_unit: TYPE = { x: device_unit | x = mL_hour }
  vtbi_unit: TYPE = { x: device_unit | x = mL }

  gpcaui_state: TYPE = [#
     is_on       : int, % on flag
     is_infusing : int, % infusing flag
     rate        : device_real, % rate
     rate_unit   : rate_unit,
     vtbi        : device_real, % vtbi
     vtbi_unit   : vtbi_unit,
     ctrl_cmd    : ControllerCMD, % Command to be sent to the GPCA state controller
     ctrl_ready  : int, % true when the controller has been initialised
     %-- data etry state
     display     : device_real, % display
     unit	 : device_unit,
     cursor      : Cursor, % cursor
     memory      : Memory  % memory
   #]

  int2boolean(i: int): boolean =
    IF i = 0 THEN FALSE ELSE TRUE ENDIF
  CONVERSION int2boolean

  init(x: device_real): gpcaui_state = (#
  	  is_on       := FALSE,
	  is_infusing := FALSE,
	  rate        := 0,
	  rate_unit   := mL_hour,
	  vtbi        := 0,
	  vtbi_unit   := mL,
	  ctrl_cmd    := CINIT,
	  ctrl_ready  := FALSE,
	  display     := x,
	  unit        := mL, % for now we can enter just vtbi
	  cursor      := 0,
	  memory      := NA
  #)
  CONVERSION init

  gpcaui_init?(st: gpcaui_state): boolean =
  	  is_on(st)       = FALSE AND
	  is_infusing(st) = FALSE AND
	  rate(st)        = 0 AND
	  vtbi(st)      = 0 AND
	  ctrl_cmd(st)    = CINIT AND
	  ctrl_ready(st)  = FALSE AND
	  display(st)     = 0 AND
	  cursor(st)      = 0 AND
	  memory(st)      = NA
  

  %-- On Off button
  %      - when the pump is on, you can switch it off, unless it's infusing
  %      - when the pump is off, you can only switch it on
  gpcaui_on(st: gpcaui_state): gpcaui_state =
    IF     is_on(st)  THEN IF NOT is_infusing(st) THEN init(0) WITH [ is_on := FALSE ] ELSE st ENDIF
    ELSE   init(0) WITH [ is_on := TRUE ] ENDIF


  %-- Start button
  gpcaui_start(st: gpcaui_state): gpcaui_state =
    IF    is_on(st) AND display(st) > 0 AND vtbi(st) > 0 AND rate(st) > 0 
    THEN  st WITH [ ctrl_cmd 	:= IF ctrl_cmd(st) = C4E
    	     	    		   THEN C94 %-- start infusion
				   ELSE C46 %-- resume infusion
				   ENDIF,
    	     	    is_infusing := true ]
    ELSE  st ENDIF

  %-- Stop button
  gpcaui_stop(st: gpcaui_state): gpcaui_state =
    IF    is_on(st)
    THEN  st WITH [ ctrl_cmd := C43, %-- pause infusion
    	     	    is_infusing := false ]
    ELSE  st ENDIF

  %-- tick
  gpcaui_tick(st: gpcaui_state): gpcaui_state =
    IF     is_on(st) AND ctrl_ready(st) 
     THEN  IF NOT is_infusing(st)
     	   THEN IF    ctrl_cmd(st) = C4D THEN st WITH [ ctrl_cmd := C4A ] %-- auto-confirm rate (this prototype uses a fixed rate)
	   	ELSIF ctrl_cmd(st) = C4A THEN st WITH [ ctrl_cmd := C4E ] %-- auto-confirm program settings after entering rate
%	   	ELSIF ctrl_cmd(st) = C43 THEN st WITH [ ctrl_cmd := C44 ] %-- auto-confirm pause infusion
		ELSE  st ENDIF
     	   ELSIF is_infusing(st)
           THEN  IF display(st) > 0 AND vtbi(st) > 0 AND rate(st) > 0
      	         THEN  LET new_vtbi: real = IF vtbi(st) - rate(st) > 0 THEN vtbi(st) - rate(st) ELSE 0 ENDIF %floor(v(st) - r(st) / 100)
            	        IN st WITH [ vtbi := new_vtbi, 
			             display := new_vtbi, 
				     is_infusing := IF new_vtbi = 0 THEN false ELSE is_infusing(st) ENDIF ]
	   	 ELSE  st ENDIF
           ELSE st ENDIF
     ELSE % init sequence 42->93->4F->86->88->51->8A->8C->8E->48->4D->4A->4E->94
     	   COND  ctrl_cmd(st) = CINIT -> st WITH [ ctrl_cmd := C42 ], %-- power up
           	 ctrl_cmd(st) = C42   -> st WITH [ ctrl_cmd := C93 ], %-- check adminstration set
	   	 ctrl_cmd(st) = C93   -> st WITH [ ctrl_cmd := C4F ], %-- ? 
	   	 ctrl_cmd(st) = C4F   -> st WITH [ ctrl_cmd := C86 ], %-- prime line
	   	 ctrl_cmd(st) = C86   -> st WITH [ ctrl_cmd := C88 ], %-- display drug info
	   	 ctrl_cmd(st) = C88   -> st WITH [ ctrl_cmd := C51 ], %-- check drug type
	   	 ctrl_cmd(st) = C51   -> st WITH [ ctrl_cmd := C8A ], %-- ?
	   	 ctrl_cmd(st) = C8A   -> st WITH [ ctrl_cmd := C8C ], %-- ?
	   	 ctrl_cmd(st) = C8C   -> st WITH [ ctrl_cmd := C8E ], %-- ?
	   	 ctrl_cmd(st) = C8E   -> st WITH [ ctrl_cmd := C48 ], %-- configure infusion program
%	   	 ctrl_cmd(st) = C48   -> st WITH [ ctrl_cmd := C4D ], %-- confirm VTBI
%	   	 ctrl_cmd(st) = C4D   -> st WITH [ ctrl_cmd := C4A ], %-- confirm rate (this prototype uses a fixed rate)
%	   	 ctrl_cmd(st) = C4A   -> st WITH [ ctrl_cmd := C4E ], %-- confirm infusion program
%	   	 ctrl_cmd(st) = C4E   -> st WITH [ ctrl_cmd := C94 ], %-- start infusion
	   	 ctrl_cmd(st) = C48   -> st WITH [ ctrl_ready := TRUE ] 
	   ENDCOND ENDIF


  
  %-- interactive data entry sub-system
  pow10(i: Cursor): device_real = ^(10,i);

  min_value(st: gpcaui_state): device_real = 
   LET i = cursor(st), val = display(st) 
    IN IF i >= 3 AND val >= 1          THEN 1
       ELSIF (i >= 0 AND i < 3) 
             OR (i < 0 AND val >= 0.1) THEN 0.1 ELSE 0 ENDIF

  min_position(st: gpcaui_state): Cursor = 
   LET val = display(st) IN
    COND
      val < 100        -> -2,
      val >= 100 
        AND val < 1000 -> -1,
      val >= 1000      -> 0
    ENDCOND

  limit(min_val: device_real): [real -> real] =
    LAMBDA (val: real): IF val > 0 AND val < min_val THEN min_val ELSE val ENDIF

  %-- down button
  dn: [gpcaui_state -> gpcaui_state] =
      LAMBDA (st: gpcaui_state):
        LET val = display(st),
            i = cursor(st),
            mem = memory(st),
            min_val = min_value(st),
            new_val = val - pow10(i),
            new_mem = IF i >= 0 THEN mem(pow10(i)) ELSE mem ENDIF
          IN
          COND val <= min_val -> st WITH [ display := 0, cursor := i, memory := NA ],
               val > min_val  ->
                 COND new_val = 0 -> st WITH [ display := 0, cursor := i, memory := NA ],
                      new_val /= 0 AND new_val >= min_val ->
                       LET new_val = limit(min_val)(new_val) IN
                        IF valid?(mem) THEN st WITH [ display := value(mem), cursor := i, memory := NA ]
                        ELSE st WITH [ display := new_val, cursor := i, memory := NA ]
                        ENDIF,
                      new_val /= 0 AND new_val < min_val ->
                        IF valid?(mem) THEN st WITH [ display := min_val, cursor := i, memory := NA ]
                        ELSE st WITH [display := min_val, cursor := i, memory := new_mem ]
                        ENDIF
                 ENDCOND
          ENDCOND

  %-- up button
  up: [gpcaui_state -> gpcaui_state] =
      LAMBDA (st: gpcaui_state):
        LET val = display(st),
            i = cursor(st),
            mem = memory(st),
            new_val =
              COND
                val + pow10(i) < 0.1                            -> 0.1,
                val + pow10(i) >= 0.1 AND val + pow10(i) < 100  -> val + pow10(i),
                val + pow10(i) >= 100 AND val + pow10(i) < 1000 -> floor((val + pow10(i)) * 10) / 10,
                val + pow10(i) >= 1000                          -> floor(val + pow10(i))
              ENDCOND,
            new_mem = mem(val)
          IN
          COND val = max -> st,
               val < max ->
               COND
                 new_val > max ->
                   IF valid?(mem) THEN st WITH [ display := max, cursor := i, memory := mem ]
                   ELSE st WITH [ display := max, cursor := i, memory := new_mem ]
                   ENDIF,
                 new_val <= max ->
                   IF valid?(mem) THEN st WITH [ display := value(mem), cursor := i, memory := NA ]
                   ELSE st WITH [ display := new_val, cursor := i, memory := NA ]
                   ENDIF
               ENDCOND
          ENDCOND

  %-- left button
  lf: [gpcaui_state -> gpcaui_state] =
   LAMBDA(st: gpcaui_state):
     LET val = display(st), i = cursor(st), mem = memory(st) IN
      COND
        i < 4 -> st WITH [ display := val, cursor := i + 1, memory := NA ],
        i = 4 -> st WITH [ display := val, cursor := i    , memory := mem ]
      ENDCOND

  %-- right button
  rt: [gpcaui_state -> gpcaui_state] =
    LAMBDA(st: gpcaui_state): 
      LET val = display(st), i = cursor(st), mem = memory(st), min_pos = min_position(st) IN
       COND
         i > min_pos  -> st WITH [ display := val, cursor := i - 1, memory := NA ],
         i <= min_pos -> st WITH [ display := val, cursor := i    , memory := mem ]
       ENDCOND


  gpcaui_dn(st: gpcaui_state): gpcaui_state =
    IF is_on(st) AND ctrl_ready(st) THEN dn(st)
    ELSE st ENDIF

  gpcaui_up(st: gpcaui_state): gpcaui_state =
    IF is_on(st) AND ctrl_ready(st) THEN up(st)
    ELSE st ENDIF

  gpcaui_lf(st: gpcaui_state): gpcaui_state =
    IF is_on(st) AND ctrl_ready(st) THEN lf(st)
    ELSE st ENDIF

  gpcaui_rt(st: gpcaui_state): gpcaui_state =
    IF is_on(st) AND ctrl_ready(st) THEN rt(st)
    ELSE st ENDIF

  gpcaui_ok(st: gpcaui_state): gpcaui_state =
    IF is_on(st) AND display(st) > 0 AND ctrl_ready(st) 
    THEN st WITH [ ctrl_cmd := C4D,
    	    	   vtbi := display(st), 
    	    	   rate := 0.1 ] 
    ELSE st ENDIF

 END gpcaui

