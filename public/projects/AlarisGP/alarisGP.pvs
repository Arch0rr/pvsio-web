alarisGP: THEORY
 BEGIN

  %-- constants & type definitions -sdd-------------------------------------------------------------------------------
  max: nonneg_real = 1200
  min: nonneg_real = 0.01
  alaris_real: TYPE = {x: nonneg_real | x <= max}

  % note: the tick rate accelerates when timer = 0 -- we are not modelling this for now.
  tick: TYPE = nat
  max_timer: tick = 5
  alaris_timer: TYPE = upto(max_timer)
  decrement(t: alaris_timer, n: tick): alaris_timer = IF t - n >= 0 THEN t - n ELSE t ENDIF

  time: TYPE = nonneg_real % milliseconds
  time2tick(t: time): tick

  tiny_step: alaris_real = 0.1
  small_step: alaris_real = 1
  big_step: alaris_real = 10
  alaris_step: TYPE = {x: alaris_real | x = small_step OR x = big_step OR x = tiny_step}

  state: TYPE = [# display: alaris_real, timer: alaris_timer, step: alaris_step #]
  
  init(x: alaris_real): state = (# display := x, timer := max_timer, step := small_step #)
  %----------------------------------------------------------------------------------------------------------------


  %-- utility functions -------------------------------------------------------------------------------------------
  trim(x: real): alaris_real = IF x > max THEN max ELSIF x < 0 THEN 0 ELSE x ENDIF
  ceil(x: real): real = ceiling(x)
  %----------------------------------------------------------------------------------------------------------------


  %-- alaris' chevron (UP,up,dn,DN) -------------------------------------------------------------------------------
  alaris_up(delta: alaris_step, val: alaris_real): alaris_real = 
     IF    val < 100                 THEN trim( floor((val*10) + delta) / 10 )
     ELSIF val >= 100 AND val < 1000 THEN trim( floor((val) + delta) )
     ELSE                                 trim( (floor(val/10) + delta) * 10 ) ENDIF

  alaris_UP(delta: alaris_step, val: alaris_real): alaris_real = 
     IF    val < 100                 THEN trim( floor(val) + delta )
     ELSIF val >= 100 AND val < 1000 THEN trim( (floor(val/10) + delta) * 10 )
     ELSE                                 trim( (floor(val/100) + delta) * 100 ) ENDIF

  %-- note: dn(100) = 99 (and not 99.9)
  alaris_dn(delta: alaris_step, val: alaris_real): alaris_real = 
     IF    val < 100                THEN trim( (ceil(val*10) - delta) / 10 )
     ELSIF val >= 100 AND val < 1000  THEN trim( ceil(val - delta) )
     ELSE                                 trim( (ceil(val/10) - delta) * 10 ) ENDIF

  %-- the conditions for DN are apparently slightly different from those of the other buttons...
  alaris_DN(delta: alaris_step, val: alaris_real): alaris_real = 
     IF    val < 100                THEN trim( ceil(val) - delta)
     ELSIF val >= 100 AND val < 1000  THEN trim( (ceil(val/10) - delta) * 10 )
     ELSE                                 trim( (ceil(val/100) - delta) * 100 ) ENDIF
  %----------------------------------------------------------------------------------------------------------------

  %-- release key--------------------------------------------------------------------------------------------------
  release_key(st: state): state =
       st WITH [ timer := max_timer, step := small_step ]
  %----------------------------------------------------------------------------------------------------------------


  %-- UP ----------------------------------------------------------------------------------------------------------
  % This is the behaviour of the old firmware. In the new firmware, the current step depends on the previous step.
  press_UP(st: state): state =
      LET t: alaris_timer = decrement(timer(st), 1),
          s: alaris_step  =
            IF t = 0 AND step(st) = small_step 
                 AND ((display(st) < 100 AND fractional(display(st) / 10 ) = 0) 
                        OR (display(st) > 100 AND fractional(display(st) / 100 ) = 0))
              THEN big_step
            ELSE step(st) ENDIF,
          d: alaris_real = alaris_UP(s, display(st))
        IN st WITH [display := d, timer := t, step := s]
  
  release_UP(st: state): state = release_key(st)

  click_UP(st: state): state = release_key(press_UP(st))
  %----------------------------------------------------------------------------------------------------------------


  %-- up ----------------------------------------------------------------------------------------------------------
  % This is the behaviour of the old firmware. In the new firmware, the current step depends on the previous step.
  press_up(st: state): state =
      LET d: alaris_real = alaris_up(small_step, display(st))
        IN st WITH [ display := d ]

  release_up(st: state): state = release_key(st)

  click_up(st: state): state = release_key(press_up(st))
  %----------------------------------------------------------------------------------------------------------------


  %-- DN ----------------------------------------------------------------------------------------------------------
  % This is the behaviour of the old firmware. In the new firmware, the current step depends on the previous step.
  press_DN(st: state): state =
      LET t: alaris_timer = decrement(timer(st), 1),
          s: alaris_step  =
            COND
               t = 0 AND step(st) = small_step 
                 AND ((display(st) > 10 AND display(st) < 100 AND fractional(display(st) / 10 ) = 0) 
                        OR (display(st) > 100 AND fractional(display(st) / 100 ) = 0))
                    -> big_step,

               t /= max_timer AND step(st) = big_step AND (display(st) = 10 OR display(st) = 100)
                    -> small_step,

               ELSE -> step(st) ENDCOND,
          d: alaris_real = alaris_DN(s, display(st))
        IN st WITH [display := d, timer := t, step := s]

  release_DN(st: state): state = release_key(st)

  click_DN(st: state): state = release_key(press_DN(st))
  %----------------------------------------------------------------------------------------------------------------


  %-- dn ----------------------------------------------------------------------------------------------------------
  % This is the behaviour of the old firmware. In the new firmware, the current step depends on the previous step.
  press_dn(st: state): state =
      LET d: alaris_real = alaris_dn(small_step, display(st))
        IN st WITH [ display := d ]

  release_dn(st: state): state = release_key(st)

  click_dn(st: state): state = release_key(press_dn(st))
  %----------------------------------------------------------------------------------------------------------------


  %{"_block" : "BlockStart", "_id" : "StateName", "_type": "Nodes"}
  StateName: TYPE = { Idle, Inc, Dec };
  %{"_block" : "BlockEnd", "_id" : "StateName", "_type": "Nodes"}

  %{"_block" : "BlockStart", "_id" : "State", "_type": "State"}
  State: TYPE = [#
    alaris_state: state,
    current_state: StateName,
    previous_state: StateName
  #]
  %{"_block" : "BlockEnd", "_id" : "State", "_type": "State"}
  
  initial_state: State = (#
    alaris_state := init(0),
    current_state := Idle,
    previous_state := Idle
  #)

  %{"_block" : "BlockStart", "_id" : "leave_state", "_type": "Function"}
  leave_state(s: StateName)(st: State): State = st WITH [ previous_state := s ] 
  %{"_block" : "BlockEnd", "_id" : "leave_state", "_type": "Function"}
  %{"_block" : "BlockStart", "_id" : "enter_into", "_type": "Function"}
  enter_into(s: StateName)(st: State): State = st WITH [ current_state := s ] 
  %{"_block" : "BlockEnd", "_id" : "enter_into", "_type": "Function"}

  %{"_block": "BlockStart" , "_id" : "user_press_UP", "_type": "Permission"}
  per_user_press_UP(st: State) : bool = 
     current_state(st) = Idle OR current_state(st) = Inc
  %{"_block": "BlockEnd" , "_id" : "user_press_UP", "_type": "Permission"}  

  %{"_block": "BlockStart" , "_id" : "user_press_UP", "_type": "Edge"}
  user_press_UP(st: (per_user_press_UP)): State = 
  COND
  %{"_block": "BlockStart", "_id" : "user_press_UP", "_source" : "Idle", "_target" : "Inc", "_type": "Transition"}
     st`current_state = Idle
    -> LET new_st = leave_state(Idle)(st),
           new_st = new_st WITH [ alaris_state := press_UP(new_st`alaris_state) ]
        IN enter_into(Inc)(new_st),
  %{"_block": "BlockEnd", "_id" : "user_press_UP", "_source" : "Idle", "_target" : "Inc", "_type": "Transition"} 
  %{"_block": "BlockStart", "_id" : "user_press_UP", "_source" : "Inc", "_target" : "Inc", "_type": "Transition"}
     st`current_state = Inc
    -> LET new_st = leave_state(Inc)(st),
           new_st = new_st WITH [ alaris_state := press_UP(new_st`alaris_state) ]
        IN enter_into(Inc)(new_st)
  %{"_block": "BlockEnd", "_id" : "user_press_UP", "_source" : "Inc", "_target" : "Inc", "_type": "Transition"} 
  ENDCOND
  %{"_block": "BlockEnd" , "_id" : "user_press_UP", "_type": "Edge"}

  %{"_block": "BlockStart" , "_id" : "user_release_UP", "_type": "Permission"}
  per_user_release_UP(st: State) : bool = current_state(st) = Inc
  %{"_block": "BlockEnd" , "_id" : "user_release_UP", "_type": "Permission"}  

  %{"_block": "BlockStart" , "_id" : "user_release_UP", "_type": "Edge"}
  user_release_UP(st: (per_user_release_UP)): State = 
  COND
  %{"_block": "BlockStart", "_id" : "user_release_UP", "_source" : "Inc", "_target" : "Idle", "_type": "Transition"}
     st`current_state = Inc
    -> LET new_st = leave_state(Inc)(st),
           new_st = new_st WITH [ alaris_state := release_UP(new_st`alaris_state) ]
        IN enter_into(Idle)(new_st)
  %{"_block": "BlockEnd", "_id" : "user_release_UP", "_source" : "Inc", "_target" : "Idle", "_type": "Transition"} 
  ENDCOND
  %{"_block": "BlockEnd" , "_id" : "user_release_UP", "_type": "Edge"}


  %{"_block": "BlockStart" , "_id" : "user_press_DN", "_type": "Permission"}
  per_user_press_DN(st: State) : bool = 
  	current_state(st) = Idle OR current_state(st) = Dec
  %{"_block": "BlockEnd" , "_id" : "user_press_DN", "_type": "Permission"}  

  %{"_block": "BlockStart" , "_id" : "user_press_DN", "_type": "Edge"}
  user_press_DN(st: (per_user_press_DN)): State = 
  COND
  %{"_block": "BlockStart", "_id" : "user_press_DN", "_source" : "Idle", "_target" : "Dec", "_type": "Transition"}
     st`current_state = Idle
    -> LET new_st = leave_state(Idle)(st),
           new_st = new_st WITH [ alaris_state := press_DN(new_st`alaris_state) ]
        IN enter_into(Dec)(new_st),
  %{"_block": "BlockEnd", "_id" : "user_press_DN", "_source" : "Idle", "_target" : "Dec", "_type": "Transition"} 
  %{"_block": "BlockStart", "_id" : "user_press_DN", "_source" : "Dec", "_target" : "Dec", "_type": "Transition"}
     st`current_state = Dec
    -> LET new_st = leave_state(Dec)(st),
           new_st = new_st WITH [ alaris_state := press_DN(new_st`alaris_state) ]
        IN enter_into(Dec)(new_st)
  %{"_block": "BlockEnd", "_id" : "user_press_DN", "_source" : "Dec", "_target" : "Dec", "_type": "Transition"} 
  ENDCOND
  %{"_block": "BlockEnd" , "_id" : "user_press_DN", "_type": "Edge"}

  %{"_block": "BlockStart" , "_id" : "user_release_DN", "_type": "Permission"}
  per_user_release_DN(st: State) : bool = current_state(st) = Dec
  %{"_block": "BlockEnd" , "_id" : "user_release_DN", "_type": "Permission"}  

  %{"_block": "BlockStart" , "_id" : "user_release_DN", "_type": "Edge"}
  user_release_DN(st: (per_user_release_DN)): State = 
  COND
  %{"_block": "BlockStart", "_id" : "user_release_DN", "_source" : "Dec", "_target" : "Idle", "_type": "Transition"}
     st`current_state = Dec
    -> LET new_st = leave_state(Dec)(st),
           new_st = new_st WITH [ alaris_state := release_DN(new_st`alaris_state) ]
        IN enter_into(Idle)(new_st)
  %{"_block": "BlockEnd", "_id" : "user_release_DN", "_source" : "Dec", "_target" : "Idle", "_type": "Transition"} 
  ENDCOND
  %{"_block": "BlockEnd" , "_id" : "user_release_DN", "_type": "Edge"}

 END alarisGP
